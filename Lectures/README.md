## Java基础

### 11 Java jdk 介绍

Java运行机制及运行过程
- .java ->编译 .class ->运行（操作系统JVM虚拟机）
  - JVM负责执行指令，管理数据、内存、寄存器。

### 35 变量

Java变量基本要素（类型+名称+值）

### 40 数据类型

**Java数据类型**： 
- 基本数据类型：数值型，字符型，布尔型
- 引用数据类型：类class，接口interface，数组([])

### 156 数组必要性
- 定义一个数组：double[] hens = (3, 5, 1}; 或 double hens[] = {3, 5, 1};
- 数组的定义
  - 动态初始化 int a[] = new int[5] new在堆里申请内存
  - 动态初始化 先声明数组再创建数组 int a[]; a = new int[10];
  - 静态初始化 如果知道数组有多少元素
- 数组属于引用类型，数组型数据是对象（object）

### 166 数组拷贝
- 要求数据空间是独立的

### 169 数组扩容

## 面向对象编程

### 192 类与对象

单独变量解决，不利于数据的管理。

- 对象[属性,行为]

### 195 对象内存布局

- 栈内存对象名/对象引用
- 堆内存对象-地址（字符串）和基本数据类型
- 字符串引用类型存在方法区常量池

在方法区加载类的信息（属性信息，行为）
- 访问修饰符 protected/public/private

### 200 对象创建过程

- 栈：存放基本数据类型
- 堆：存放对象
- 方法区：常量池，类加载信息

### 201 成员方法

- 访问修饰符（控制方法的使用范围）

### 227 方法重载

### 234 可变参数

Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。
- public int sum(int... nums){}

### 236 作用域

- 属性和局部变量

### 240 构造器Constructor

构造器是类的一种特殊方法，主要作用时对新对象的初始化。
- 如果没有定义构造器，系统会自动给类生成一个默认无参构造器。

### 245 this

java虚拟机会给每个对象分配this，代表当前对象。

### 273 包

包的作用
- 区分相同名字的类
- 当类很多时，可以很好的管理类（看Java API文档）
- 控制访问范围

包的基本语法
- package表示打包
- com.hspedu表示包名

常用的包
- java.lang. 基本包
- java.util. 系统工具包，使用Scanner
- java.net. 网络包，网络开发
- jaba.awt. java界面的开发，GUI

### 279 访问修饰符

- public
- protected：对子类和同一个包中的类公开
- 默认：向同一个包的类公开
- private：只有类本身可以访问

### 280 封装

封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起。

**封装实现的步骤**
- 将属性私有化private
- 提供一个public的set方法，用于对属性判断并赋值（数据验证的业务逻辑）。
- 提供一个public的get方法，用于获取属性的值（权限判断）。

### 286 继承

代码复用性-extend。当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。

class子类 extends父类{}
- 子类会自动拥有父类定义的属性和方法。
- 子类继承所有的属性和方法，但是私有属性不能在子类直接访问，需要通过公共的方法去访问。
- 子类必须调用父类的构造器，完成父类的初始化。
- 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作。否则，编译不会通过。

### 297 super

super代表父类的引用，用于访问父类的属性、方法、构造器。

- 访问父类的属性，但不能访问父类的private属性-> super.属性名
- 访问父类的方法，但不能访问父类的private方法-> super.方法名
- 访问父类的构造器，只能放在构造器第一句

super带来的便利
- 调用父类构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）
- 当子类中有和父类中的成员重名时，为了访问父类的成员，必须同过super。如果没有重名，使用super、this、直接访问是一样的效果。

子类找方法的顺序：
- 先找本类方法，如果有并且可以调用，则调用
- 如果没有，则找父类方法。
- 如果父类没有，则继续找父类的父类。
如果查找方法的过程中，找到了，但是不能访问，则报错。

### 301 方法重写/覆盖（override）

方法覆盖（重写）就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法。
- 子类方法的返回类型和父类返回类型一样，或者父类返回类型的子类。
- 子类方法不能缩小父类方法的访问权限。

### 306 poly多态

多态的前提是：两个对象（类）存在继承关系。
- 可以调用父类的所有成员。但是不能调用子类的特有成员。
  - 向上转型
  - 向下转型

### 314 动态绑定机制

- 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定。
- 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。

### 315 多态数组

- 数组的定义类型为父态类型，里面保存的实际元素类型为子类类型。
  - isinstanceof 判断运行类型

### 318 object类

- clone()
- equals 
  - 只能判断引用类型
- getClass()
- hashCode()
- toString()

### 325 hashCode

- 如果指向同一个对象，则哈希值肯定是一样的。
- 如果指向不同对象，哈希值是不一样的。
- 哈希值主要是根据地址号，但不能将哈希值等价于地址。

### 325 toString

返回对象的字符串表示。默认返回全类名（包名+类名）+@+哈希值的十六进制。

### 327 finalize

当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
- 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作。
- 什么时候被回收：当某个对象没有任何引用时，则jvm认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象。销毁对象前，会调用finalize方法。
- 垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制。

### 374 类变量（静态变量）

静态变量会被类的所有实例共享。static变量保存在class实例的尾部。
- 任何一个该类对象访问它，取到的都是相同的值。任何一个该类的对象去修改它，修改的也是同一个变量。

- 定义：访问修饰符 static 数据类型 变量名
- 访问：类名.类变量名



### 536 Map接口实现类HashMap

HashMap以k-v对形式存储数据。添加相同的key，会覆盖原来的key-value。
