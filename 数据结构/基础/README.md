## 数据结构

### 1. 数组

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。除了数组，链表、队列、栈等也是线性表结构。

![image](https://user-images.githubusercontent.com/46979228/184301712-daafb990-4e1f-4bf4-ad73-62d5868ca0b2.png)

非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

数组的特性：
- 连续的内存空间和相同类型的数据。
  - 优势是“随机访问”。寻址公式： a[i]_address = base_address + i * data_type_size
  - 数组与链表区别：数组支持随机访问，根据下标/偏移（offset）随机访问的时间复杂度为 O(1)。链表适合插入、删除，时间复杂度 O(1)；
  - 但数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。
- 数组的访问越界问题
  - 函数体内的局部变量存在栈上，且是连续压栈。如果i和arr是元素同类型，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。
- 容器
  - ArrayList 优势就是可以将很多数组操作的细节封装起来。
  - 支持动态扩容。但最好在创建 ArrayList 的时候事先指定数据大小。

### 2. 链表 Linked List

常见的缓存策略：
- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

链表恰恰相反，通过“指针”将一组零散的内存块串联起来使用。

Pillars: 单链表、双向链表和循环链表。

**单链表**
- 查找需要遍历。
- 尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找对应的时间复杂度为 O(n)。

**循环链表**

**双向链表**

数组的缺点是大小固定。链表本身没有大小的限制，天然地支持动态扩容。

![image](https://user-images.githubusercontent.com/46979228/184306267-b1bbccd2-2984-4da0-87af-b81754f87465.png)

基于链表实现 LRU 缓存淘汰算法
- p->next=q。p 结点中的 next 指针存储了 q 结点的内存地址。
- p->next=p->next->next。p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。


```
// 结点 p 后面插入一个新的结点
new_node->next = p->next;
p->next = new_node;

// 删除结点 p 的后继结点
p->next = p->next->next;
```

留意边界条件处理
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

**练习**
- 单链表反转 [206]
- 链表中环的检测 [141]
- 两个有序的链表合并 [21]
- 删除链表倒数第 n 个结点
- 求链表的中间结点


### 3. 栈 Stack

后进者先出，先进者后出。栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。

栈只支持两个基本操作：入栈 push()和出栈 pop()。

操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。


### 4. 队列 Queue

先进者先出。

队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，

用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。


### 5. 递归 Recursion

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

## 查找

### 6. 二分查找

### 7. 跳表 Skip List

动态数据结构，可以支持快速地插入、删除、查找操作。甚至可以替代红黑树(Red-black tree)。

Redis中的有序集合(Sorted Set)用跳表实现。对链表建立一级“索引”。查找时先遍历索引层，然后通过down指针下降到原始链表。链表加多级索引的结构就是跳表。

- k级索引节点的个数n/(s^k)。时间复杂度O(m*logn)。空间换时间。空间复杂度O(n)。

**跳表索引动态更新**
- 通过随机函数维护索引与原始链表之间大小平衡。

### 8. 散列表

散列表是数组的一种扩展，由数组演化而来。hash(key)

**散列冲突**
- 开放寻址法(open addressing)
  - 线性探测(Linear Probing)
  - 二次探测(Quadratic Probing)
  - 双重散列(Double Hashing)
  - 用装载因子(load factor)来表示空位的多少。填入表中的元素个数/散列表的长度
- 链表法(chaining)
  - 通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可。k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。

**如何设计散列函数**
- 散列函数生成的值要尽可能随机并且均匀分布。
- 分批动态扩容。
- 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。
- 链表法对内存的利用率比开放寻址法要高。


### 贪心算法 Greedy Algorithm - 用贪心算法实现Huffman压缩编码






